Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENMUL
    COMMENUNI
    DOSPUNTOS
    EQUALS
    ID
    POT

Grammar

Rule 0     S' -> init
Rule 1     init -> instrucciones
Rule 2     instrucciones -> instrucciones instruccion
Rule 3     instrucciones -> instruccion
Rule 4     instruccion -> print_instr finins
Rule 5     finins -> SALTOLINEA
Rule 6     finins -> <empty>
Rule 7     instruccion -> error finins
Rule 8     print_instr -> RPRINT PARIZQ expresion PARDER
Rule 9     expresion -> CADENA
Rule 10    expresion -> expresion PLUS expresion
Rule 11    expresion -> expresion MINUS expresion
Rule 12    expresion -> expresion POR expresion
Rule 13    expresion -> expresion DIVIDE expresion
Rule 14    expresion -> expresion MODULATE expresion
Rule 15    expresion -> PARIZQ expresion PARDER
Rule 16    expresion -> INTEGER
Rule 17    expresion -> FLOAT

Terminals, with rules where they appear

CADENA               : 9
COMMENMUL            : 
COMMENUNI            : 
DIVIDE               : 14
DOSPUNTOS            : 
EQUALS               : 
FLOAT                : 17
ID                   : 
INTEGER              : 16
MINUS                : 11
MODULATE             : 14
PARDER               : 8 15
PARIZQ               : 8 15
PLUS                 : 10
POR                  : 12
POT                  : 
RPRINT               : 8
SALTOLINEA           : 5
error                : 7

Nonterminals, with rules where they appear

expresion            : 8 10 10 11 11 12 12 13 13 14 14 15
finins               : 4
init                 : 0
instruccion          : 2 3
instrucciones        : 1 2
print_instr          : 4

Parsing method: LALR

state 0

    (0) S' -> . init
    (1) init -> . instrucciones
    (2) instrucciones -> . instrucciones instruccion
    (3) instrucciones -> . instruccion
    (4) instruccion -> . print_instr finins
    (7) instruccion -> . error finins
    (8) print_instr -> . RPRINT PARIZQ expresion PARDER

    error           shift and go to state 5
    RPRINT          shift and go to state 6

    init                           shift and go to state 1
    instrucciones                  shift and go to state 2
    instruccion                    shift and go to state 3
    print_instr                    shift and go to state 4

state 1

    (0) S' -> init .



state 2

    (1) init -> instrucciones .
    (2) instrucciones -> instrucciones . instruccion
    (4) instruccion -> . print_instr finins
    (7) instruccion -> . error finins
    (8) print_instr -> . RPRINT PARIZQ expresion PARDER

    $end            reduce using rule 1 (init -> instrucciones .)
    error           shift and go to state 5
    RPRINT          shift and go to state 6

    instruccion                    shift and go to state 7
    print_instr                    shift and go to state 4

state 3

    (3) instrucciones -> instruccion .

    error           reduce using rule 3 (instrucciones -> instruccion .)
    RPRINT          reduce using rule 3 (instrucciones -> instruccion .)
    $end            reduce using rule 3 (instrucciones -> instruccion .)


state 4

    (4) instruccion -> print_instr . finins
    (5) finins -> . SALTOLINEA
    (6) finins -> .

    SALTOLINEA      shift and go to state 9
    error           reduce using rule 6 (finins -> .)
    RPRINT          reduce using rule 6 (finins -> .)
    $end            reduce using rule 6 (finins -> .)

    finins                         shift and go to state 8

state 5

    (7) instruccion -> error . finins
    (5) finins -> . SALTOLINEA
    (6) finins -> .

    SALTOLINEA      shift and go to state 9
    error           reduce using rule 6 (finins -> .)
    RPRINT          reduce using rule 6 (finins -> .)
    $end            reduce using rule 6 (finins -> .)

    finins                         shift and go to state 10

state 6

    (8) print_instr -> RPRINT . PARIZQ expresion PARDER

    PARIZQ          shift and go to state 11


state 7

    (2) instrucciones -> instrucciones instruccion .

    error           reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    RPRINT          reduce using rule 2 (instrucciones -> instrucciones instruccion .)
    $end            reduce using rule 2 (instrucciones -> instrucciones instruccion .)


state 8

    (4) instruccion -> print_instr finins .

    error           reduce using rule 4 (instruccion -> print_instr finins .)
    RPRINT          reduce using rule 4 (instruccion -> print_instr finins .)
    $end            reduce using rule 4 (instruccion -> print_instr finins .)


state 9

    (5) finins -> SALTOLINEA .

    error           reduce using rule 5 (finins -> SALTOLINEA .)
    RPRINT          reduce using rule 5 (finins -> SALTOLINEA .)
    $end            reduce using rule 5 (finins -> SALTOLINEA .)


state 10

    (7) instruccion -> error finins .

    error           reduce using rule 7 (instruccion -> error finins .)
    RPRINT          reduce using rule 7 (instruccion -> error finins .)
    $end            reduce using rule 7 (instruccion -> error finins .)


state 11

    (8) print_instr -> RPRINT PARIZQ . expresion PARDER
    (9) expresion -> . CADENA
    (10) expresion -> . expresion PLUS expresion
    (11) expresion -> . expresion MINUS expresion
    (12) expresion -> . expresion POR expresion
    (13) expresion -> . expresion DIVIDE expresion
    (14) expresion -> . expresion MODULATE expresion
    (15) expresion -> . PARIZQ expresion PARDER
    (16) expresion -> . INTEGER
    (17) expresion -> . FLOAT

    CADENA          shift and go to state 14
    PARIZQ          shift and go to state 12
    INTEGER         shift and go to state 15
    FLOAT           shift and go to state 16

    expresion                      shift and go to state 13

state 12

    (15) expresion -> PARIZQ . expresion PARDER
    (9) expresion -> . CADENA
    (10) expresion -> . expresion PLUS expresion
    (11) expresion -> . expresion MINUS expresion
    (12) expresion -> . expresion POR expresion
    (13) expresion -> . expresion DIVIDE expresion
    (14) expresion -> . expresion MODULATE expresion
    (15) expresion -> . PARIZQ expresion PARDER
    (16) expresion -> . INTEGER
    (17) expresion -> . FLOAT

    CADENA          shift and go to state 14
    PARIZQ          shift and go to state 12
    INTEGER         shift and go to state 15
    FLOAT           shift and go to state 16

    expresion                      shift and go to state 17

state 13

    (8) print_instr -> RPRINT PARIZQ expresion . PARDER
    (11) expresion -> expresion . PLUS expresion
    (12) expresion -> expresion . MINUS expresion
    (13) expresion -> expresion . POR expresion
    (14) expresion -> expresion . DIVIDE expresion
    (15) expresion -> expresion . MODULATE expresion

    PARDER          shift and go to state 18
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20
    POR             shift and go to state 21
    DIVIDE          shift and go to state 22
    MODULATE        shift and go to state 23


state 14

    (9) expresion -> CADENA .

    PARDER          reduce using rule 9 (expresion -> CADENA .)
    PLUS            reduce using rule 9 (expresion -> CADENA .)
    MINUS           reduce using rule 9 (expresion -> CADENA .)
    POR             reduce using rule 9 (expresion -> CADENA .)
    DIVIDE          reduce using rule 9 (expresion -> CADENA .)
    MODULATE        reduce using rule 9 (expresion -> CADENA .)


state 15

    (16) expresion -> INTEGER .

    PARDER          reduce using rule 16 (expresion -> INTEGER .)
    PLUS            reduce using rule 16 (expresion -> INTEGER .)
    MINUS           reduce using rule 16 (expresion -> INTEGER .)
    POR             reduce using rule 16 (expresion -> INTEGER .)
    DIVIDE          reduce using rule 16 (expresion -> INTEGER .)
    MODULATE        reduce using rule 16 (expresion -> INTEGER .)


state 16

    (17) expresion -> FLOAT .

    PARDER          reduce using rule 17 (expresion -> FLOAT .)
    PLUS            reduce using rule 17 (expresion -> FLOAT .)
    MINUS           reduce using rule 17 (expresion -> FLOAT .)
    POR             reduce using rule 17 (expresion -> FLOAT .)
    DIVIDE          reduce using rule 17 (expresion -> FLOAT .)
    MODULATE        reduce using rule 17 (expresion -> FLOAT .)


state 17

    (15) expresion -> PARIZQ expresion . PARDER
    (10) expresion -> expresion . PLUS expresion
    (11) expresion -> expresion . MINUS expresion
    (12) expresion -> expresion . POR expresion
    (13) expresion -> expresion . DIVIDE expresion
    (14) expresion -> expresion . MODULATE expresion

    PARDER          shift and go to state 24
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20
    POR             shift and go to state 21
    DIVIDE          shift and go to state 22
    MODULATE        shift and go to state 23


state 18

    (8) print_instr -> RPRINT PARIZQ expresion PARDER .

    SALTOLINEA      reduce using rule 8 (print_instr -> RPRINT PARIZQ expresion PARDER .)
    error           reduce using rule 8 (print_instr -> RPRINT PARIZQ expresion PARDER .)
    RPRINT          reduce using rule 8 (print_instr -> RPRINT PARIZQ expresion PARDER .)
    $end            reduce using rule 8 (print_instr -> RPRINT PARIZQ expresion PARDER .)


state 19

    (10) expresion -> expresion PLUS . expresion
    (9) expresion -> . CADENA
    (10) expresion -> . expresion PLUS expresion
    (11) expresion -> . expresion MINUS expresion
    (12) expresion -> . expresion POR expresion
    (13) expresion -> . expresion DIVIDE expresion
    (14) expresion -> . expresion MODULATE expresion
    (15) expresion -> . PARIZQ expresion PARDER
    (16) expresion -> . INTEGER
    (17) expresion -> . FLOAT

    CADENA          shift and go to state 14
    PARIZQ          shift and go to state 12
    INTEGER         shift and go to state 15
    FLOAT           shift and go to state 16

    expresion                      shift and go to state 25

state 20

    (11) expresion -> expresion PLUS . expresion
    (9) expresion -> . CADENA
    (10) expresion -> . expresion PLUS expresion
    (11) expresion -> . expresion MINUS expresion
    (12) expresion -> . expresion POR expresion
    (13) expresion -> . expresion DIVIDE expresion
    (14) expresion -> . expresion MODULATE expresion
    (15) expresion -> . PARIZQ expresion PARDER
    (16) expresion -> . INTEGER
    (17) expresion -> . FLOAT

    CADENA          shift and go to state 14
    PARIZQ          shift and go to state 12
    INTEGER         shift and go to state 15
    FLOAT           shift and go to state 16

    expresion                      shift and go to state 26

state 21

    (12) expresion -> expresion MINUS . expresion
    (9) expresion -> . CADENA
    (10) expresion -> . expresion PLUS expresion
    (11) expresion -> . expresion MINUS expresion
    (12) expresion -> . expresion POR expresion
    (13) expresion -> . expresion DIVIDE expresion
    (14) expresion -> . expresion MODULATE expresion
    (15) expresion -> . PARIZQ expresion PARDER
    (16) expresion -> . INTEGER
    (17) expresion -> . FLOAT

    CADENA          shift and go to state 14
    PARIZQ          shift and go to state 12
    INTEGER         shift and go to state 15
    FLOAT           shift and go to state 16

    expresion                      shift and go to state 27

state 22

    (13) expresion -> expresion POR . expresion
    (9) expresion -> . CADENA
    (10) expresion -> . expresion PLUS expresion
    (11) expresion -> . expresion MINUS expresion
    (12) expresion -> . expresion POR expresion
    (13) expresion -> . expresion DIVIDE expresion
    (14) expresion -> . expresion MODULATE expresion
    (15) expresion -> . PARIZQ expresion PARDER
    (16) expresion -> . INTEGER
    (17) expresion -> . FLOAT

    CADENA          shift and go to state 14
    PARIZQ          shift and go to state 12
    INTEGER         shift and go to state 15
    FLOAT           shift and go to state 16

    expresion                      shift and go to state 28

state 23

    (14) expresion -> expresion DIVIDE . expresion
    (9) expresion -> . CADENA
    (10) expresion -> . expresion PLUS expresion
    (11) expresion -> . expresion MINUS expresion
    (12) expresion -> . expresion POR expresion
    (13) expresion -> . expresion DIVIDE expresion
    (14) expresion -> . expresion MODULATE expresion
    (15) expresion -> . PARIZQ expresion PARDER
    (16) expresion -> . INTEGER
    (17) expresion -> . FLOAT

    CADENA          shift and go to state 14
    PARIZQ          shift and go to state 12
    INTEGER         shift and go to state 15
    FLOAT           shift and go to state 16

    expresion                      shift and go to state 29

state 24

    (15) expresion -> PARIZQ expresion PARDER .

    PARDER          reduce using rule 15 (expresion -> PARIZQ expresion PARDER .)
    PLUS            reduce using rule 15 (expresion -> PARIZQ expresion PARDER .)
    MINUS           reduce using rule 15 (expresion -> PARIZQ expresion PARDER .)
    POR             reduce using rule 15 (expresion -> PARIZQ expresion PARDER .)
    DIVIDE          reduce using rule 15 (expresion -> PARIZQ expresion PARDER .)
    MODULATE        reduce using rule 15 (expresion -> PARIZQ expresion PARDER .)


state 25

    (10) expresion -> expresion PLUS expresion .
    (10) expresion -> expresion . PLUS expresion
    (11) expresion -> expresion . MINUS expresion
    (12) expresion -> expresion . POR expresion
    (13) expresion -> expresion . DIVIDE expresion
    (14) expresion -> expresion . MODULATE expresion

    CADENA          shift and go to state 13
    ID              shift and go to state 14

    expresion                      shift and go to state 25

state 21

    (11) expresion -> expresion PLUS expresion .
    (11) expresion -> expresion . PLUS expresion
    (12) expresion -> expresion . MINUS expresion
    (13) expresion -> expresion . POR expresion
    (14) expresion -> expresion . DIVIDE expresion
    (15) expresion -> expresion . MODULATE expresion

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for POR resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULATE resolved as shift
    PARDER          reduce using rule 10 (expresion -> expresion PLUS expresion .)
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20
    POR             shift and go to state 21
    DIVIDE          shift and go to state 22
    MODULATE        shift and go to state 23

  ! PLUS            [ reduce using rule 11 (expresion -> expresion PLUS expresion .) ]
  ! MINUS           [ reduce using rule 11 (expresion -> expresion PLUS expresion .) ]
  ! POR             [ reduce using rule 11 (expresion -> expresion PLUS expresion .) ]
  ! DIVIDE          [ reduce using rule 11 (expresion -> expresion PLUS expresion .) ]
  ! MODULATE        [ reduce using rule 11 (expresion -> expresion PLUS expresion .) ]


state 26

    (12) expresion -> expresion MINUS expresion .
    (11) expresion -> expresion . PLUS expresion
    (12) expresion -> expresion . MINUS expresion
    (13) expresion -> expresion . POR expresion
    (14) expresion -> expresion . DIVIDE expresion
    (15) expresion -> expresion . MODULATE expresion

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for POR resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULATE resolved as shift
    PARDER          reduce using rule 11 (expresion -> expresion MINUS expresion .)
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20
    POR             shift and go to state 21
    DIVIDE          shift and go to state 22
    MODULATE        shift and go to state 23

  ! PLUS            [ reduce using rule 12 (expresion -> expresion MINUS expresion .) ]
  ! MINUS           [ reduce using rule 12 (expresion -> expresion MINUS expresion .) ]
  ! POR             [ reduce using rule 12 (expresion -> expresion MINUS expresion .) ]
  ! DIVIDE          [ reduce using rule 12 (expresion -> expresion MINUS expresion .) ]
  ! MODULATE        [ reduce using rule 12 (expresion -> expresion MINUS expresion .) ]


state 27

    (13) expresion -> expresion POR expresion .
    (11) expresion -> expresion . PLUS expresion
    (12) expresion -> expresion . MINUS expresion
    (13) expresion -> expresion . POR expresion
    (14) expresion -> expresion . DIVIDE expresion
    (15) expresion -> expresion . MODULATE expresion

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for POR resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULATE resolved as shift
    PARDER          reduce using rule 12 (expresion -> expresion POR expresion .)
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20
    POR             shift and go to state 21
    DIVIDE          shift and go to state 22
    MODULATE        shift and go to state 23

  ! PLUS            [ reduce using rule 13 (expresion -> expresion POR expresion .) ]
  ! MINUS           [ reduce using rule 13 (expresion -> expresion POR expresion .) ]
  ! POR             [ reduce using rule 13 (expresion -> expresion POR expresion .) ]
  ! DIVIDE          [ reduce using rule 13 (expresion -> expresion POR expresion .) ]
  ! MODULATE        [ reduce using rule 13 (expresion -> expresion POR expresion .) ]


state 28

    (14) expresion -> expresion DIVIDE expresion .
    (11) expresion -> expresion . PLUS expresion
    (12) expresion -> expresion . MINUS expresion
    (13) expresion -> expresion . POR expresion
    (14) expresion -> expresion . DIVIDE expresion
    (15) expresion -> expresion . MODULATE expresion

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for POR resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULATE resolved as shift
    PARDER          reduce using rule 13 (expresion -> expresion DIVIDE expresion .)
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20
    POR             shift and go to state 21
    DIVIDE          shift and go to state 22
    MODULATE        shift and go to state 23

  ! PLUS            [ reduce using rule 14 (expresion -> expresion DIVIDE expresion .) ]
  ! MINUS           [ reduce using rule 14 (expresion -> expresion DIVIDE expresion .) ]
  ! POR             [ reduce using rule 14 (expresion -> expresion DIVIDE expresion .) ]
  ! DIVIDE          [ reduce using rule 14 (expresion -> expresion DIVIDE expresion .) ]
  ! MODULATE        [ reduce using rule 14 (expresion -> expresion DIVIDE expresion .) ]


state 29

    (15) expresion -> expresion MODULATE expresion .
    (11) expresion -> expresion . PLUS expresion
    (12) expresion -> expresion . MINUS expresion
    (13) expresion -> expresion . POR expresion
    (14) expresion -> expresion . DIVIDE expresion
    (15) expresion -> expresion . MODULATE expresion

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for POR resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULATE resolved as shift
    PARDER          reduce using rule 14 (expresion -> expresion MODULATE expresion .)
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20
    POR             shift and go to state 21
    DIVIDE          shift and go to state 22
    MODULATE        shift and go to state 23

  ! PLUS            [ reduce using rule 15 (expresion -> expresion MODULATE expresion .) ]
  ! MINUS           [ reduce using rule 15 (expresion -> expresion MODULATE expresion .) ]
  ! POR             [ reduce using rule 15 (expresion -> expresion MODULATE expresion .) ]
  ! DIVIDE          [ reduce using rule 15 (expresion -> expresion MODULATE expresion .) ]
  ! MODULATE        [ reduce using rule 15 (expresion -> expresion MODULATE expresion .) ]

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 25 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 25 resolved as shift
WARNING: shift/reduce conflict for POR in state 25 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 25 resolved as shift
WARNING: shift/reduce conflict for MODULATE in state 25 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 26 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 26 resolved as shift
WARNING: shift/reduce conflict for POR in state 26 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 26 resolved as shift
WARNING: shift/reduce conflict for MODULATE in state 26 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 27 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 27 resolved as shift
WARNING: shift/reduce conflict for POR in state 27 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 27 resolved as shift
WARNING: shift/reduce conflict for MODULATE in state 27 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 28 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 28 resolved as shift
WARNING: shift/reduce conflict for POR in state 28 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 28 resolved as shift
WARNING: shift/reduce conflict for MODULATE in state 28 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 29 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 29 resolved as shift
WARNING: shift/reduce conflict for POR in state 29 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 29 resolved as shift
WARNING: shift/reduce conflict for MODULATE in state 29 resolved as shift
